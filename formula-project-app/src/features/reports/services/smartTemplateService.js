/**
 * Smart Template Service - Intelligent, context-aware report templates
 * SiteCam-inspired automation for Formula PM
 * Phase 2: Smart Automation Agent
 */

import { generateUniqueId } from '../../../utils/generators/idGenerator';
import photoService from './photoService';
import metadataService from './metadataService';

class SmartTemplateService {
  constructor() {
    this.templates = new Map();
    this.init();
  }

  init() {
    // Load smart template configurations
    this.loadSmartTemplates();
  }

  /**
   * Generate intelligent report based on photo metadata and context
   */
  async generateSmartReport(projectId, photos, templateType = 'auto') {
    try {
      // Analyze photos to determine best template
      const analysisResult = await this.analyzePhotos(photos);
      
      // Auto-select template if not specified
      if (templateType === 'auto') {
        templateType = this.selectOptimalTemplate(analysisResult, photos);
      }

      // Get smart template configuration
      const template = this.getSmartTemplate(templateType);
      
      // Generate report structure
      const reportStructure = await this.buildReportFromPhotos(
        projectId, 
        photos, 
        template, 
        analysisResult
      );

      return {
        success: true,
        reportStructure,
        template,
        analysisResult,
        metadata: {
          generatedAt: new Date().toISOString(),
          photoCount: photos.length,
          templateType,
          confidence: analysisResult.confidence
        }
      };
    } catch (error) {
      console.error('Error generating smart report:', error);
      throw new Error('Failed to generate smart report: ' + error.message);
    }
  }

  /**
   * Analyze photos to extract patterns and context
   */
  async analyzePhotos(photos) {
    const analysis = {
      totalPhotos: photos.length,
      timeSpan: this.calculateTimeSpan(photos),
      locations: this.groupByLocation(photos),
      workCategories: this.groupByWorkCategory(photos),
      photoCategories: this.groupByPhotoCategory(photos),
      timeline: this.buildTimeline(photos),
      patterns: this.detectPatterns(photos),
      confidence: 0.8 // Default confidence score
    };

    // Calculate confidence based on data quality
    analysis.confidence = this.calculateAnalysisConfidence(analysis);

    return analysis;
  }

  /**
   * Select optimal template based on photo analysis
   */
  selectOptimalTemplate(analysis, photos) {
    const { workCategories, photoCategories, timeline, patterns } = analysis;

    // Progress report if photos span multiple days with progress patterns
    if (timeline.days > 1 && patterns.progressSequence) {
      return 'smart-progress';
    }

    // Quality report if many quality/inspection photos
    const qualityRatio = (photoCategories.quality || 0) / photos.length;
    if (qualityRatio > 0.4) {
      return 'smart-quality';
    }

    // Issue report if many issue/defect photos
    const issueRatio = (photoCategories.issue || 0) / photos.length;
    if (issueRatio > 0.3) {
      return 'smart-issue';
    }

    // Safety report if safety photos present
    if (photoCategories.safety > 0) {
      return 'smart-safety';
    }

    // Default to comprehensive progress report
    return 'smart-progress';
  }

  /**
   * Build complete report structure from photos
   */
  async buildReportFromPhotos(projectId, photos, template, analysis) {
    const reportStructure = {
      id: generateUniqueId('RPT'),
      projectId,
      title: this.generateSmartTitle(template, analysis),
      type: template.type,
      status: 'draft',
      createdAt: new Date().toISOString(),
      metadata: {
        reportNumber: this.generateReportNumber(),
        reportDate: new Date().toISOString().split('T')[0],
        reportPeriod: this.calculateReportPeriod(analysis.timeline),
        projectPhase: this.inferProjectPhase(analysis),
        weather: this.extractWeatherInfo(photos),
        workingHours: this.calculateWorkingHours(analysis.timeline),
        autoGenerated: true,
        generationMethod: 'smart-template',
        photoAnalysis: analysis
      },
      sections: await this.generateSmartSections(photos, template, analysis),
      exportSettings: template.exportSettings || this.getDefaultExportSettings()
    };

    return reportStructure;
  }

  /**
   * Generate intelligent sections based on photos and template
   */
  async generateSmartSections(photos, template, analysis) {
    const sections = [];

    for (const sectionTemplate of template.sections) {
      const section = {
        id: generateUniqueId('SEC'),
        title: sectionTemplate.title,
        type: sectionTemplate.type,
        order: sections.length + 1,
        lines: await this.generateSectionLines(photos, sectionTemplate, analysis)
      };

      // Only include sections that have content
      if (section.lines.length > 0) {
        sections.push(section);
      }
    }

    return sections;
  }

  /**
   * Generate lines for a section based on photo content
   */
  async generateSectionLines(photos, sectionTemplate, analysis) {
    const lines = [];

    switch (sectionTemplate.type) {
      case 'summary':
        lines.push(...await this.generateSummaryLines(photos, analysis));
        break;
      case 'progress':
        lines.push(...await this.generateProgressLines(photos, analysis));
        break;
      case 'locations':
        lines.push(...await this.generateLocationLines(photos, analysis));
        break;
      case 'issues':
        lines.push(...await this.generateIssueLines(photos, analysis));
        break;
      case 'quality':
        lines.push(...await this.generateQualityLines(photos, analysis));
        break;
      case 'safety':
        lines.push(...await this.generateSafetyLines(photos, analysis));
        break;
      case 'timeline':
        lines.push(...await this.generateTimelineLines(photos, analysis));
        break;
      default:
        lines.push(...await this.generateGeneralLines(photos, sectionTemplate));
        break;
    }

    return lines;
  }

  /**
   * Generate summary lines based on overall analysis
   */
  async generateSummaryLines(photos, analysis) {
    const lines = [];
    
    // Overall summary
    const summaryText = this.generateOverallSummary(analysis);
    lines.push({
      id: generateUniqueId('LINE'),
      order: 1,
      description: summaryText,
      images: this.selectRepresentativeImages(photos, 2),
      tags: ['summary', 'overview'],
      category: 'summary'
    });

    return lines;
  }

  /**
   * Generate progress-focused lines
   */
  async generateProgressLines(photos, analysis) {
    const lines = [];
    const progressPhotos = photos.filter(p => p.category === 'progress' || p.category === 'milestone');

    // Group by location for progress tracking
    const locationGroups = this.groupByLocation(progressPhotos);

    Object.entries(locationGroups).forEach(([location, locationPhotos], index) => {
      if (locationPhotos.length > 0) {
        const progressDescription = this.generateProgressDescription(location, locationPhotos);
        lines.push({
          id: generateUniqueId('LINE'),
          order: index + 1,
          description: progressDescription,
          images: this.selectProgressImages(locationPhotos),
          tags: ['progress', location.toLowerCase().replace(/\s+/g, '-')],
          category: 'progress'
        });
      }
    });

    return lines;
  }

  /**
   * Generate location-based lines
   */
  async generateLocationLines(photos, analysis) {
    const lines = [];
    const locationGroups = analysis.locations;

    Object.entries(locationGroups).forEach(([location, locationPhotos], index) => {
      const locationDescription = this.generateLocationDescription(location, locationPhotos);
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: locationDescription,
        images: this.selectLocationImages(locationPhotos),
        tags: ['location', location.toLowerCase().replace(/\s+/g, '-')],
        category: 'location'
      });
    });

    return lines;
  }

  /**
   * Generate issue-focused lines
   */
  async generateIssueLines(photos, analysis) {
    const lines = [];
    const issuePhotos = photos.filter(p => 
      p.category === 'issue' || 
      p.tags.includes('defect') || 
      p.tags.includes('problem')
    );

    issuePhotos.forEach((photo, index) => {
      const issueDescription = this.generateIssueDescription(photo);
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: issueDescription,
        images: [photo],
        tags: ['issue', 'action-required', ...(photo.tags || [])],
        category: 'issue'
      });
    });

    return lines;
  }

  /**
   * Generate quality control lines
   */
  async generateQualityLines(photos, analysis) {
    const lines = [];
    const qualityPhotos = photos.filter(p => 
      p.category === 'quality' || 
      p.tags.includes('inspection') || 
      p.tags.includes('quality')
    );

    // Group by inspection type or location
    const qualityGroups = this.groupQualityPhotos(qualityPhotos);

    Object.entries(qualityGroups).forEach(([group, groupPhotos], index) => {
      const qualityDescription = this.generateQualityDescription(group, groupPhotos);
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: qualityDescription,
        images: groupPhotos,
        tags: ['quality', 'inspection', group.toLowerCase().replace(/\s+/g, '-')],
        category: 'quality'
      });
    });

    return lines;
  }

  /**
   * Generate safety-focused lines
   */
  async generateSafetyLines(photos, analysis) {
    const lines = [];
    const safetyPhotos = photos.filter(p => 
      p.category === 'safety' || 
      p.tags.includes('safety') || 
      p.tags.includes('hazard')
    );

    safetyPhotos.forEach((photo, index) => {
      const safetyDescription = this.generateSafetyDescription(photo);
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: safetyDescription,
        images: [photo],
        tags: ['safety', 'compliance', ...(photo.tags || [])],
        category: 'safety'
      });
    });

    return lines;
  }

  /**
   * Generate timeline-based lines
   */
  async generateTimelineLines(photos, analysis) {
    const lines = [];
    const timelineGroups = this.groupPhotosByTimePeríod(photos);

    Object.entries(timelineGroups).forEach(([period, periodPhotos], index) => {
      const timelineDescription = this.generateTimelineDescription(period, periodPhotos);
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: timelineDescription,
        images: this.selectTimelineImages(periodPhotos),
        tags: ['timeline', period.toLowerCase().replace(/\s+/g, '-')],
        category: 'timeline'
      });
    });

    return lines;
  }

  /**
   * Generate general lines for unknown section types
   */
  async generateGeneralLines(photos, sectionTemplate) {
    const lines = [];
    
    // Simple grouping by work category
    const workGroups = this.groupByWorkCategory(photos);
    
    Object.entries(workGroups).forEach(([workCategory, workPhotos], index) => {
      lines.push({
        id: generateUniqueId('LINE'),
        order: index + 1,
        description: `${workCategory} work progress and documentation`,
        images: workPhotos.slice(0, 3), // Limit to 3 images per line
        tags: [workCategory.toLowerCase(), 'general'],
        category: 'general'
      });
    });

    return lines;
  }

  // Helper methods for generating descriptions
  generateOverallSummary(analysis) {
    const { totalPhotos, timeSpan, locations, workCategories } = analysis;
    const locationCount = Object.keys(locations).length;
    const workCategoryCount = Object.keys(workCategories).length;

    return `Report generated from ${totalPhotos} photos covering ${locationCount} locations and ${workCategoryCount} work categories over ${timeSpan.description}. Project activities documented include ${Object.keys(workCategories).join(', ')}.`;
  }

  generateProgressDescription(location, photos) {
    const workTypes = [...new Set(photos.map(p => p.project?.workCategory || 'General'))];
    const timeSpan = this.calculateTimeSpan(photos);
    
    return `Progress documentation for ${location} showing ${workTypes.join(' and ')} work activities. ${photos.length} photos captured over ${timeSpan.description} demonstrating ongoing construction progress.`;
  }

  generateLocationDescription(location, photos) {
    const categories = [...new Set(photos.map(p => p.category))];
    return `${location} documentation showing ${categories.join(', ')} activities. ${photos.length} photos captured showing current status and work progress.`;
  }

  generateIssueDescription(photo) {
    const location = this.formatLocation(photo.location);
    const workCategory = photo.project?.workCategory || 'General';
    const tags = photo.tags?.join(', ') || 'issue';
    
    return `${workCategory} issue identified in ${location}. Tagged as: ${tags}. ${photo.description || 'Requires attention and corrective action.'}`;
  }

  generateQualityDescription(group, photos) {
    const photoCount = photos.length;
    const locations = [...new Set(photos.map(p => this.formatLocation(p.location)))];
    
    return `Quality inspection for ${group} covering ${locations.join(', ')}. ${photoCount} photos documenting quality control checkpoints and compliance verification.`;
  }

  generateSafetyDescription(photo) {
    const location = this.formatLocation(photo.location);
    const tags = photo.tags?.join(', ') || 'safety';
    
    return `Safety documentation for ${location}. Tagged as: ${tags}. ${photo.description || 'Safety compliance and hazard documentation.'}`;
  }

  generateTimelineDescription(period, photos) {
    const workCategories = [...new Set(photos.map(p => p.project?.workCategory || 'General'))];
    const locations = [...new Set(photos.map(p => this.formatLocation(p.location)))];
    
    return `${period} activities showing ${workCategories.join(', ')} work across ${locations.join(', ')}. ${photos.length} photos documenting progress and activities during this period.`;
  }

  // Utility methods
  calculateTimeSpan(photos) {
    if (!photos.length) return { days: 0, description: 'No photos' };
    
    const dates = photos.map(p => new Date(p.capturedAt)).sort();
    const startDate = dates[0];
    const endDate = dates[dates.length - 1];
    const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
    
    return {
      days: daysDiff,
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      description: daysDiff === 0 ? 'single day' : `${daysDiff} days`
    };
  }

  groupByLocation(photos) {
    return photos.reduce((groups, photo) => {
      const location = this.formatLocation(photo.location);
      if (!groups[location]) groups[location] = [];
      groups[location].push(photo);
      return groups;
    }, {});
  }

  groupByWorkCategory(photos) {
    return photos.reduce((groups, photo) => {
      const category = photo.project?.workCategory || 'General';
      if (!groups[category]) groups[category] = [];
      groups[category].push(photo);
      return groups;
    }, {});
  }

  groupByPhotoCategory(photos) {
    return photos.reduce((groups, photo) => {
      const category = photo.category || 'general';
      groups[category] = (groups[category] || 0) + 1;
      return groups;
    }, {});
  }

  buildTimeline(photos) {
    const timeline = {
      startDate: null,
      endDate: null,
      days: 0,
      hours: [],
      dailyActivity: {}
    };

    if (photos.length === 0) return timeline;

    const dates = photos.map(p => new Date(p.capturedAt)).sort();
    timeline.startDate = dates[0];
    timeline.endDate = dates[dates.length - 1];
    timeline.days = Math.ceil((timeline.endDate - timeline.startDate) / (1000 * 60 * 60 * 24));

    // Build daily activity map
    photos.forEach(photo => {
      const date = photo.capturedAt.split('T')[0];
      if (!timeline.dailyActivity[date]) {
        timeline.dailyActivity[date] = [];
      }
      timeline.dailyActivity[date].push(photo);
    });

    // Extract working hours
    timeline.hours = photos.map(p => new Date(p.capturedAt).getHours());

    return timeline;
  }

  detectPatterns(photos) {
    const patterns = {
      progressSequence: false,
      locationProgression: false,
      timeConsistency: false,
      workflowSequence: false
    };

    // Detect progress sequence (before/during/after patterns)
    const progressPhotos = photos.filter(p => p.category === 'progress');
    if (progressPhotos.length >= 2) {
      patterns.progressSequence = true;
    }

    // Detect location progression
    const locations = [...new Set(photos.map(p => this.formatLocation(p.location)))];
    if (locations.length > 1) {
      patterns.locationProgression = true;
    }

    // Detect time consistency (photos taken during work hours)
    const workHours = photos.filter(p => {
      const hour = new Date(p.capturedAt).getHours();
      return hour >= 7 && hour <= 18;
    });
    patterns.timeConsistency = workHours.length / photos.length > 0.8;

    return patterns;
  }

  calculateAnalysisConfidence(analysis) {
    let confidence = 0.5; // Base confidence

    // More photos = higher confidence
    if (analysis.totalPhotos > 10) confidence += 0.2;
    else if (analysis.totalPhotos > 5) confidence += 0.1;

    // Multiple locations = higher confidence
    if (Object.keys(analysis.locations).length > 2) confidence += 0.1;

    // Time span coverage = higher confidence
    if (analysis.timeSpan.days > 0) confidence += 0.1;

    // Pattern detection = higher confidence
    if (analysis.patterns.progressSequence) confidence += 0.1;
    if (analysis.patterns.locationProgression) confidence += 0.1;

    return Math.min(confidence, 1.0);
  }

  formatLocation(location) {
    if (!location) return 'Unknown Location';
    
    const parts = [];
    if (location.building) parts.push(location.building);
    if (location.floor) parts.push(location.floor);
    if (location.room) parts.push(location.room);
    if (location.area) parts.push(location.area);
    
    return parts.length > 0 ? parts.join(' - ') : 'Unknown Location';
  }

  // Smart template definitions
  loadSmartTemplates() {
    const templates = {
      'smart-progress': {
        id: 'smart-progress',
        name: 'Smart Progress Report',
        type: 'progress',
        description: 'AI-generated progress report from photo analysis',
        sections: [
          { title: 'Executive Summary', type: 'summary', smartGeneration: true },
          { title: 'Progress by Location', type: 'locations', smartGeneration: true },
          { title: 'Work Completed', type: 'progress', smartGeneration: true },
          { title: 'Timeline Overview', type: 'timeline', smartGeneration: true }
        ],
        exportSettings: this.getDefaultExportSettings()
      },
      'smart-quality': {
        id: 'smart-quality',
        name: 'Smart Quality Report',
        type: 'quality',
        description: 'AI-generated quality control report',
        sections: [
          { title: 'Quality Overview', type: 'summary', smartGeneration: true },
          { title: 'Quality Inspections', type: 'quality', smartGeneration: true },
          { title: 'Issues Identified', type: 'issues', smartGeneration: true },
          { title: 'Location Analysis', type: 'locations', smartGeneration: true }
        ],
        exportSettings: this.getDefaultExportSettings()
      },
      'smart-issue': {
        id: 'smart-issue',
        name: 'Smart Issue Report',
        type: 'issue',
        description: 'AI-generated issue tracking report',
        sections: [
          { title: 'Issue Summary', type: 'summary', smartGeneration: true },
          { title: 'Issues by Location', type: 'issues', smartGeneration: true },
          { title: 'Action Items', type: 'issues', smartGeneration: true },
          { title: 'Timeline Analysis', type: 'timeline', smartGeneration: true }
        ],
        exportSettings: this.getDefaultExportSettings()
      },
      'smart-safety': {
        id: 'smart-safety',
        name: 'Smart Safety Report',
        type: 'safety',
        description: 'AI-generated safety compliance report',
        sections: [
          { title: 'Safety Overview', type: 'summary', smartGeneration: true },
          { title: 'Safety Documentation', type: 'safety', smartGeneration: true },
          { title: 'Compliance Items', type: 'safety', smartGeneration: true },
          { title: 'Location Safety', type: 'locations', smartGeneration: true }
        ],
        exportSettings: this.getDefaultExportSettings()
      }
    };

    Object.values(templates).forEach(template => {
      this.templates.set(template.id, template);
    });
  }

  getSmartTemplate(templateId) {
    return this.templates.get(templateId) || this.templates.get('smart-progress');
  }

  getDefaultExportSettings() {
    return {
      includeProjectDetails: true,
      includeCoverPage: true,
      includeTableOfContents: true,
      imageQuality: 'high',
      pageSize: 'A4',
      orientation: 'portrait',
      autoGenerated: true
    };
  }

  // Helper methods for photo selection
  selectRepresentativeImages(photos, count = 2) {
    // Select most representative images based on various criteria
    const sorted = photos.sort((a, b) => {
      // Prioritize milestone and progress photos
      const aScore = this.calculateImageScore(a);
      const bScore = this.calculateImageScore(b);
      return bScore - aScore;
    });
    
    return sorted.slice(0, count);
  }

  selectProgressImages(photos) {
    return photos
      .filter(p => p.category === 'progress' || p.category === 'milestone')
      .slice(0, 3);
  }

  selectLocationImages(photos) {
    return photos.slice(0, 2); // Limit to 2 images per location
  }

  selectTimelineImages(photos) {
    // Select images that best represent the timeline
    const sorted = photos.sort((a, b) => new Date(a.capturedAt) - new Date(b.capturedAt));
    return sorted.length > 3 ? [sorted[0], sorted[Math.floor(sorted.length/2)], sorted[sorted.length-1]] : sorted;
  }

  calculateImageScore(photo) {
    let score = 0;
    
    // Category-based scoring
    const categoryScores = {
      'milestone': 10,
      'progress': 8,
      'quality': 6,
      'issue': 7,
      'safety': 5,
      'general': 3
    };
    score += categoryScores[photo.category] || 0;
    
    // Tag-based scoring
    if (photo.tags?.includes('completed')) score += 5;
    if (photo.tags?.includes('milestone')) score += 3;
    if (photo.tags?.includes('inspection')) score += 2;
    
    // Description length (more detailed = higher score)
    if (photo.description?.length > 50) score += 2;
    
    return score;
  }

  // Additional utility methods
  generateReportNumber() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const sequence = Math.floor(Math.random() * 1000) + 1;
    return `RPT-${year}-${month}-${String(sequence).padStart(3, '0')}`;
  }

  calculateReportPeriod(timeline) {
    if (!timeline.startDate || !timeline.endDate) {
      const today = new Date().toISOString().split('T')[0];
      return { from: today, to: today };
    }
    
    return {
      from: timeline.startDate.toISOString().split('T')[0],
      to: timeline.endDate.toISOString().split('T')[0]
    };
  }

  inferProjectPhase(analysis) {
    // Infer project phase based on photo content
    const { photoCategories } = analysis;
    
    if (photoCategories.milestone > 0) return 'milestone';
    if (photoCategories.quality > 0) return 'quality-control';
    if (photoCategories.issue > 0) return 'issue-resolution';
    if (photoCategories.progress > 0) return 'construction';
    
    return 'active';
  }

  extractWeatherInfo(photos) {
    // Extract weather information from photo metadata if available
    // For now, return a default value
    return 'Clear conditions';
  }

  calculateWorkingHours(timeline) {
    if (!timeline.hours || timeline.hours.length === 0) {
      return '8:00 AM - 5:00 PM';
    }
    
    const minHour = Math.min(...timeline.hours);
    const maxHour = Math.max(...timeline.hours);
    
    const formatHour = (hour) => {
      const period = hour >= 12 ? 'PM' : 'AM';
      const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
      return `${displayHour}:00 ${period}`;
    };
    
    return `${formatHour(minHour)} - ${formatHour(maxHour)}`;
  }

  // Group photos by time periods
  groupPhotosByTimePeríod(photos) {
    const groups = {};
    
    photos.forEach(photo => {
      const date = new Date(photo.capturedAt);
      const period = this.getTimePeriod(date);
      
      if (!groups[period]) groups[period] = [];
      groups[period].push(photo);
    });
    
    return groups;
  }

  getTimePeriod(date) {
    const hour = date.getHours();
    
    if (hour < 12) return 'Morning';
    if (hour < 17) return 'Afternoon';
    return 'Evening';
  }

  groupQualityPhotos(photos) {
    return photos.reduce((groups, photo) => {
      const inspectionType = photo.construction?.inspectionType || 
                           photo.tags?.find(tag => tag.includes('inspection')) || 
                           'General Quality';
      
      if (!groups[inspectionType]) groups[inspectionType] = [];
      groups[inspectionType].push(photo);
      return groups;
    }, {});
  }

  generateSmartTitle(template, analysis) {
    const date = new Date().toLocaleDateString();
    const locationCount = Object.keys(analysis.locations).length;
    
    const baseTitles = {
      'smart-progress': `Progress Report - ${analysis.timeSpan.description} (${locationCount} locations)`,
      'smart-quality': `Quality Control Report - ${date} (${analysis.totalPhotos} inspections)`,
      'smart-issue': `Issue Report - ${date} (${analysis.totalPhotos} items)`,
      'smart-safety': `Safety Report - ${date} (${analysis.totalPhotos} documentation)`
    };
    
    return baseTitles[template.id] || `Smart Report - ${date}`;
  }
}

export default new SmartTemplateService();