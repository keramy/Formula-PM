/**
 * Auto Report Service - One-click report generation from photo collections
 * SiteCam-inspired automation for Formula PM
 * Phase 2: Smart Automation Agent
 */

// Simplified imports - using mock implementations for now
// import smartTemplateService from './smartTemplateService';
// import photoService from './photoService';
// import reportService from './reportService';
// import { generateUniqueId } from '../../../utils/generators/idGenerator';

// Simple ID generator for mock implementation
const generateUniqueId = (prefix = 'ID') => {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

class AutoReportService {
  constructor() {
    this.generationHistory = new Map();
    this.presets = new Map();
    this.init();
  }

  init() {
    this.loadReportPresets();
  }

  /**
   * Generate complete report from photo selection with one click (simplified mock)
   */
  async generateFromPhotos(projectId, photoSelection, options = {}) {
    try {
      const startTime = Date.now();
      
      // Validate inputs
      if (!projectId || !photoSelection || photoSelection.length === 0) {
        throw new Error('Project ID and photo selection are required');
      }

      // Simulate loading delay
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Create mock report
      const report = {
        id: generateUniqueId('RPT'),
        projectId,
        title: `Auto-Generated Report - ${new Date().toLocaleDateString()}`,
        type: options.templateType === 'auto' ? 'progress-report' : options.templateType,
        status: 'generated',
        createdAt: new Date().toISOString(),
        sections: [
          {
            id: generateUniqueId('SEC'),
            title: 'Executive Summary',
            type: 'summary',
            order: 1,
            lines: [
              {
                id: generateUniqueId('LINE'),
                order: 1,
                description: `Report generated from ${photoSelection.length} photos covering project activities`,
                images: photoSelection.slice(0, 3),
                category: 'summary'
              }
            ]
          },
          {
            id: generateUniqueId('SEC'),
            title: 'Progress Overview',
            type: 'progress',
            order: 2,
            lines: [
              {
                id: generateUniqueId('LINE'),
                order: 1,
                description: 'Construction progress continues according to schedule',
                images: photoSelection.slice(3, 6),
                category: 'progress'
              },
              {
                id: generateUniqueId('LINE'),
                order: 2,
                description: 'Quality inspections completed successfully',
                images: photoSelection.slice(6, 9),
                category: 'quality'
              }
            ]
          }
        ],
        metadata: {
          autoGenerated: true,
          generationTime: Date.now() - startTime,
          photoSelectionCriteria: options.filters || {},
          reportNumber: `AR-${Math.floor(Math.random() * 10000)}`,
          totalPhotos: photoSelection.length,
          locations: this.extractUniqueLocations(photoSelection),
          timeSpan: this.calculateTimeSpan(photoSelection)
        }
      };

      // Mock analysis result
      const analysisResult = {
        confidence: 0.85,
        totalPhotos: photoSelection.length,
        timeSpan: this.calculateTimeSpan(photoSelection),
        locations: this.extractUniqueLocations(photoSelection),
        photoCategories: this.categorizePhotos(photoSelection)
      };

      // Store generation history
      const generationRecord = {
        id: generateUniqueId('GEN'),
        reportId: report.id,
        projectId,
        photoCount: photoSelection.length,
        templateUsed: options.templateType || 'auto',
        generatedAt: new Date().toISOString(),
        generationTime: Date.now() - startTime,
        options: options,
        analysisResult: analysisResult
      };

      this.generationHistory.set(generationRecord.id, generationRecord);

      return {
        success: true,
        report,
        generationInfo: {
          ...generationRecord,
          confidence: analysisResult.confidence,
          analysisResult
        },
        recommendations: this.generateRecommendations(analysisResult, photoSelection)
      };

    } catch (error) {
      console.error('Error in auto report generation:', error);
      throw new Error('Failed to generate automatic report: ' + error.message);
    }
  }

  /**
   * Create progress update report comparing with previous reports
   */
  async createProgressUpdate(projectId, newPhotos, options = {}) {
    try {
      // Get previous reports for comparison
      const previousReports = await reportService.getReportsByProject(projectId);
      const lastProgressReport = previousReports.find(r => r.type === 'progress');

      // Analyze progress against previous state
      const progressAnalysis = await this.analyzeProgressComparison(
        projectId, 
        newPhotos, 
        lastProgressReport
      );

      // Generate progress-focused report
      const progressReport = await this.generateFromPhotos(projectId, newPhotos, {
        ...options,
        templateType: 'smart-progress',
        compareWith: lastProgressReport,
        progressAnalysis
      });

      // Enhance with progress-specific information
      if (progressReport.success) {
        progressReport.report.metadata.progressComparison = progressAnalysis;
        progressReport.progressInsights = this.generateProgressInsights(progressAnalysis);
      }

      return progressReport;

    } catch (error) {
      console.error('Error creating progress update:', error);
      throw new Error('Failed to create progress update: ' + error.message);
    }
  }

  /**
   * Generate report from filtered photo criteria
   */
  async generateFromCriteria(projectId, filterCriteria, options = {}) {
    try {
      // Get all photos for project
      const allPhotos = await photoService.getPhotosByProject(projectId);
      
      // Apply filter criteria
      const filteredPhotos = await this.filterPhotosByCriteria(allPhotos, filterCriteria);
      
      if (filteredPhotos.length === 0) {
        throw new Error('No photos match the specified criteria');
      }

      // Generate report from filtered photos
      return await this.generateFromPhotos(projectId, filteredPhotos, options);

    } catch (error) {
      console.error('Error generating report from criteria:', error);
      throw new Error('Failed to generate report from criteria: ' + error.message);
    }
  }

  /**
   * Create time-based report sequences (daily, weekly, monthly)
   */
  async createTimeSequenceReports(projectId, sequenceType = 'weekly', options = {}) {
    try {
      const allPhotos = await photoService.getPhotosByProject(projectId);
      const timeSequences = this.groupPhotosByTimeSequence(allPhotos, sequenceType);
      
      const reports = [];
      
      for (const [period, periodPhotos] of Object.entries(timeSequences)) {
        if (periodPhotos.length > 0) {
          const sequenceReport = await this.generateFromPhotos(projectId, periodPhotos, {
            ...options,
            templateType: 'smart-progress',
            reportTitle: `${sequenceType.charAt(0).toUpperCase() + sequenceType.slice(1)} Report - ${period}`
          });
          
          if (sequenceReport.success) {
            reports.push({
              period,
              report: sequenceReport.report,
              photoCount: periodPhotos.length
            });
          }
        }
      }

      return {
        success: true,
        sequenceType,
        reports,
        totalPeriods: reports.length,
        totalPhotos: allPhotos.length
      };

    } catch (error) {
      console.error('Error creating time sequence reports:', error);
      throw new Error('Failed to create time sequence reports: ' + error.message);
    }
  }

  /**
   * Generate report from photo timeline with before/after sequences
   */
  async generateTimelineReport(projectId, photos, options = {}) {
    try {
      // Sort photos by capture time
      const sortedPhotos = photos.sort((a, b) => 
        new Date(a.capturedAt) - new Date(b.capturedAt)
      );

      // Detect before/after sequences
      const sequences = this.detectPhotoSequences(sortedPhotos);
      
      // Generate timeline-focused report
      const timelineReport = await smartTemplateService.generateSmartReport(
        projectId, 
        sortedPhotos, 
        'smart-progress'
      );

      // Enhance with sequence information
      timelineReport.reportStructure.metadata.photoSequences = sequences;
      timelineReport.reportStructure.sections = this.enhanceWithSequences(
        timelineReport.reportStructure.sections, 
        sequences
      );

      // Create the report
      const report = await reportService.createReport(timelineReport.reportStructure);

      return {
        success: true,
        report,
        sequences,
        timelineAnalysis: {
          totalPhotos: sortedPhotos.length,
          timeSpan: this.calculateTimeSpan(sortedPhotos),
          sequencesDetected: sequences.length
        }
      };

    } catch (error) {
      console.error('Error generating timeline report:', error);
      throw new Error('Failed to generate timeline report: ' + error.message);
    }
  }

  /**
   * Bulk generate reports for multiple projects
   */
  async bulkGenerateReports(projectConfigs, options = {}) {
    try {
      const results = [];
      
      for (const config of projectConfigs) {
        try {
          const projectPhotos = await photoService.getPhotosByProject(config.projectId);
          const filteredPhotos = this.applyPhotoFilters(projectPhotos, config.filters);
          
          if (filteredPhotos.length > 0) {
            const report = await this.generateFromPhotos(config.projectId, filteredPhotos, {
              ...options,
              ...config.options
            });
            
            results.push({
              projectId: config.projectId,
              success: true,
              report: report.report,
              photoCount: filteredPhotos.length
            });
          } else {
            results.push({
              projectId: config.projectId,
              success: false,
              error: 'No photos match criteria'
            });
          }
        } catch (error) {
          results.push({
            projectId: config.projectId,
            success: false,
            error: error.message
          });
        }
      }

      return {
        success: true,
        results,
        totalProjects: projectConfigs.length,
        successfulReports: results.filter(r => r.success).length
      };

    } catch (error) {
      console.error('Error in bulk report generation:', error);
      throw new Error('Failed to bulk generate reports: ' + error.message);
    }
  }

  // Helper methods

  /**
   * Resolve photo selection to actual photo data
   */
  async resolvePhotoData(photoSelection) {
    if (Array.isArray(photoSelection) && photoSelection.length > 0) {
      // If first item is a string, assume they're photo IDs
      if (typeof photoSelection[0] === 'string') {
        const photos = [];
        for (const photoId of photoSelection) {
          const photo = await photoService.getPhoto(photoId);
          if (photo) photos.push(photo);
        }
        return photos;
      }
      // Otherwise assume they're photo objects
      return photoSelection;
    }
    
    throw new Error('Invalid photo selection format');
  }

  /**
   * Apply photo filters
   */
  applyPhotoFilters(photos, filters = {}) {
    let filtered = [...photos];

    // Date range filter
    if (filters.dateFrom) {
      filtered = filtered.filter(p => p.capturedAt >= filters.dateFrom);
    }
    if (filters.dateTo) {
      filtered = filtered.filter(p => p.capturedAt <= filters.dateTo);
    }

    // Category filter
    if (filters.categories && filters.categories.length > 0) {
      filtered = filtered.filter(p => filters.categories.includes(p.category));
    }

    // Location filter
    if (filters.locations && filters.locations.length > 0) {
      filtered = filtered.filter(p => {
        const location = this.formatLocation(p.location);
        return filters.locations.some(loc => location.includes(loc));
      });
    }

    // Work category filter
    if (filters.workCategories && filters.workCategories.length > 0) {
      filtered = filtered.filter(p => 
        filters.workCategories.includes(p.project?.workCategory)
      );
    }

    // Tag filter
    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter(p => 
        filters.tags.some(tag => p.tags?.includes(tag))
      );
    }

    // Quality filter
    if (filters.minQuality) {
      filtered = filtered.filter(p => 
        this.calculatePhotoQuality(p) >= filters.minQuality
      );
    }

    return filtered;
  }

  /**
   * Filter photos by advanced criteria
   */
  async filterPhotosByCriteria(photos, criteria) {
    let filtered = [...photos];

    // Time-based criteria
    if (criteria.timePeriod) {
      filtered = this.filterByTimePeriod(filtered, criteria.timePeriod);
    }

    // Content-based criteria
    if (criteria.contentType) {
      filtered = this.filterByContentType(filtered, criteria.contentType);
    }

    // Progress-based criteria
    if (criteria.progressStage) {
      filtered = this.filterByProgressStage(filtered, criteria.progressStage);
    }

    // Sequence criteria
    if (criteria.includeSequences) {
      filtered = this.includeOnlySequences(filtered);
    }

    return filtered;
  }

  /**
   * Group photos by time sequences
   */
  groupPhotosByTimeSequence(photos, sequenceType) {
    const sequences = {};
    
    photos.forEach(photo => {
      const date = new Date(photo.capturedAt);
      let key;
      
      switch (sequenceType) {
        case 'daily':
          key = date.toISOString().split('T')[0]; // YYYY-MM-DD
          break;
        case 'weekly':
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          key = `Week of ${weekStart.toISOString().split('T')[0]}`;
          break;
        case 'monthly':
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          break;
        default:
          key = date.toISOString().split('T')[0];
      }
      
      if (!sequences[key]) sequences[key] = [];
      sequences[key].push(photo);
    });
    
    return sequences;
  }

  /**
   * Detect before/during/after photo sequences
   */
  detectPhotoSequences(sortedPhotos) {
    const sequences = [];
    const locationGroups = this.groupPhotosByLocation(sortedPhotos);
    
    Object.entries(locationGroups).forEach(([location, locationPhotos]) => {
      if (locationPhotos.length >= 2) {
        // Sort by time within location
        const sorted = locationPhotos.sort((a, b) => 
          new Date(a.capturedAt) - new Date(b.capturedAt)
        );
        
        // Detect sequences based on time gaps and content
        let currentSequence = [sorted[0]];
        
        for (let i = 1; i < sorted.length; i++) {
          const timeDiff = new Date(sorted[i].capturedAt) - new Date(sorted[i-1].capturedAt);
          const hoursDiff = timeDiff / (1000 * 60 * 60);
          
          // If photos are within 24 hours and show progression, group them
          if (hoursDiff <= 24 && this.isProgressionSequence(currentSequence, sorted[i])) {
            currentSequence.push(sorted[i]);
          } else {
            // End current sequence if it has multiple photos
            if (currentSequence.length >= 2) {
              sequences.push({
                id: generateUniqueId('SEQ'),
                location,
                photos: currentSequence,
                type: this.classifySequenceType(currentSequence),
                timeSpan: this.calculateTimeSpan(currentSequence)
              });
            }
            currentSequence = [sorted[i]];
          }
        }
        
        // Add final sequence if valid
        if (currentSequence.length >= 2) {
          sequences.push({
            id: generateUniqueId('SEQ'),
            location,
            photos: currentSequence,
            type: this.classifySequenceType(currentSequence),
            timeSpan: this.calculateTimeSpan(currentSequence)
          });
        }
      }
    });
    
    return sequences;
  }

  /**
   * Analyze progress comparison with previous reports
   */
  async analyzeProgressComparison(projectId, newPhotos, previousReport) {
    const analysis = {
      newPhotoCount: newPhotos.length,
      previousPhotoCount: 0,
      locationProgress: {},
      workCategoryProgress: {},
      timeComparison: null,
      progressDelta: 0,
      newLocations: [],
      completedItems: [],
      newIssues: []
    };

    if (previousReport) {
      // Extract previous photo count
      const previousPhotos = await this.extractPhotosFromReport(previousReport);
      analysis.previousPhotoCount = previousPhotos.length;
      
      // Compare locations
      const newLocations = this.getUniqueLocations(newPhotos);
      const previousLocations = this.getUniqueLocations(previousPhotos);
      analysis.newLocations = newLocations.filter(loc => !previousLocations.includes(loc));
      
      // Analyze work category progress
      analysis.workCategoryProgress = this.compareWorkCategories(newPhotos, previousPhotos);
      
      // Calculate progress delta
      analysis.progressDelta = this.calculateProgressDelta(newPhotos, previousPhotos);
      
      // Time comparison
      analysis.timeComparison = this.compareTimePeriods(
        previousReport.metadata.reportPeriod,
        this.calculateReportPeriod(newPhotos)
      );
    }

    return analysis;
  }

  /**
   * Generate recommendations based on analysis
   */
  generateRecommendations(analysisResult, photos) {
    const recommendations = [];
    
    // Photo quality recommendations
    if (analysisResult.confidence < 0.7) {
      recommendations.push({
        type: 'quality',
        priority: 'medium',
        message: 'Consider adding more photos or improving photo documentation for better report accuracy'
      });
    }
    
    // Location coverage recommendations
    if (Object.keys(analysisResult.locations).length < 3) {
      recommendations.push({
        type: 'coverage',
        priority: 'low',
        message: 'Consider documenting additional project locations for comprehensive reporting'
      });
    }
    
    // Time span recommendations
    if (analysisResult.timeSpan.days === 0) {
      recommendations.push({
        type: 'timeline',
        priority: 'medium',
        message: 'Consider capturing photos over multiple days to show progress over time'
      });
    }
    
    // Category balance recommendations
    const categories = analysisResult.photoCategories;
    const hasIssues = categories.issue > 0;
    const hasProgress = categories.progress > 0;
    
    if (hasIssues && !hasProgress) {
      recommendations.push({
        type: 'balance',
        priority: 'high',
        message: 'Consider including progress photos to balance issue documentation'
      });
    }

    return recommendations;
  }

  // Utility methods

  formatLocation(location) {
    if (!location) return 'Unknown Location';
    
    const parts = [];
    if (location.building) parts.push(location.building);
    if (location.floor) parts.push(location.floor);
    if (location.room) parts.push(location.room);
    if (location.area) parts.push(location.area);
    
    return parts.length > 0 ? parts.join(' - ') : 'Unknown Location';
  }

  calculatePhotoQuality(photo) {
    let score = 5; // Base score
    
    // Resolution scoring
    if (photo.quality?.resolution) {
      const { width, height } = photo.quality.resolution;
      const megapixels = (width * height) / 1000000;
      if (megapixels > 8) score += 2;
      else if (megapixels > 4) score += 1;
    }
    
    // Metadata completeness
    if (photo.description?.length > 20) score += 1;
    if (photo.tags?.length > 2) score += 1;
    if (photo.location?.room && photo.location?.area) score += 1;
    
    return Math.min(score, 10);
  }

  calculateTimeSpan(photos) {
    if (!photos.length) return { days: 0, description: 'No photos' };
    
    const dates = photos.map(p => new Date(p.capturedAt)).sort();
    const startDate = dates[0];
    const endDate = dates[dates.length - 1];
    const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
    
    return {
      days: daysDiff,
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      description: daysDiff === 0 ? 'single day' : `${daysDiff} days`
    };
  }

  groupPhotosByLocation(photos) {
    return photos.reduce((groups, photo) => {
      const location = this.formatLocation(photo.location);
      if (!groups[location]) groups[location] = [];
      groups[location].push(photo);
      return groups;
    }, {});
  }

  isProgressionSequence(currentSequence, newPhoto) {
    // Simple heuristic: same location, different time, progress-related tags
    const lastPhoto = currentSequence[currentSequence.length - 1];
    const sameLocation = this.formatLocation(lastPhoto.location) === this.formatLocation(newPhoto.location);
    const progressTags = ['progress', 'before', 'during', 'after', 'completed'];
    const hasProgressTags = progressTags.some(tag => 
      lastPhoto.tags?.includes(tag) || newPhoto.tags?.includes(tag)
    );
    
    return sameLocation && (hasProgressTags || lastPhoto.category === 'progress' || newPhoto.category === 'progress');
  }

  classifySequenceType(photos) {
    const tags = photos.flatMap(p => p.tags || []);
    
    if (tags.includes('before') && tags.includes('after')) return 'before-after';
    if (tags.includes('progress')) return 'progress-sequence';
    if (photos.every(p => p.category === 'quality')) return 'quality-sequence';
    if (photos.every(p => p.category === 'issue')) return 'issue-sequence';
    
    return 'time-sequence';
  }

  enhanceWithSequences(sections, sequences) {
    // Add sequence information to existing sections
    if (sequences.length > 0) {
      const sequenceSection = {
        id: generateUniqueId('SEC'),
        title: 'Photo Sequences & Timeline',
        type: 'timeline',
        order: sections.length + 1,
        lines: sequences.map((sequence, index) => ({
          id: generateUniqueId('LINE'),
          order: index + 1,
          description: `${sequence.type} sequence in ${sequence.location} (${sequence.photos.length} photos over ${sequence.timeSpan.description})`,
          images: sequence.photos,
          tags: ['sequence', sequence.type],
          category: 'timeline'
        }))
      };
      
      sections.push(sequenceSection);
    }
    
    return sections;
  }

  // Load default report presets
  loadReportPresets() {
    const presets = {
      'daily-progress': {
        name: 'Daily Progress',
        filters: {
          timePeriod: 'today',
          categories: ['progress', 'milestone']
        },
        templateType: 'smart-progress'
      },
      'weekly-summary': {
        name: 'Weekly Summary',
        filters: {
          timePeriod: 'week',
          categories: ['progress', 'quality', 'milestone']
        },
        templateType: 'smart-progress'
      },
      'quality-inspection': {
        name: 'Quality Inspection',
        filters: {
          categories: ['quality', 'issue'],
          tags: ['inspection', 'quality-control']
        },
        templateType: 'smart-quality'
      },
      'issue-tracking': {
        name: 'Issue Tracking',
        filters: {
          categories: ['issue'],
          tags: ['defect', 'problem', 'action-required']
        },
        templateType: 'smart-issue'
      }
    };

    Object.entries(presets).forEach(([id, preset]) => {
      this.presets.set(id, { id, ...preset });
    });
  }

  /**
   * Get available report presets
   */
  getReportPresets() {
    return Array.from(this.presets.values());
  }

  /**
   * Get generation history
   */
  getGenerationHistory(projectId = null) {
    let history = Array.from(this.generationHistory.values());
    
    if (projectId) {
      history = history.filter(record => record.projectId === projectId);
    }
    
    return history.sort((a, b) => new Date(b.generatedAt) - new Date(a.generatedAt));
  }

  async getProjectData(projectId) {
    // Mock project data for demo purposes
    // In real implementation, this would fetch from API
    const mockProjects = {
      '2001': { name: 'One Sixty Sixth Street Residential' },
      '2002': { name: 'Sophisticated Hotel Manhattan' },
      '2003': { name: 'Corporate Office Building Brooklyn' },
      '2004': { name: 'Luxury Apartment Complex Queens' },
      '2005': { name: 'Modern Shopping Center Bronx' }
    };

    return mockProjects[projectId] || { name: 'Unknown Project' };
  }

  // Helper methods for simplified implementation
  extractUniqueLocations(photos) {
    const locations = {};
    photos.forEach(photo => {
      const location = this.formatLocation(photo.location);
      locations[location] = (locations[location] || 0) + 1;
    });
    return locations;
  }

  categorizePhotos(photos) {
    const categories = { progress: 0, quality: 0, issue: 0, milestone: 0, other: 0 };
    photos.forEach(photo => {
      const category = photo.category || 'other';
      categories[category] = (categories[category] || 0) + 1;
    });
    return categories;
  }
}

export default new AutoReportService();